using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Readers;

namespace Flowcast.CodeGenerator;

/// <summary>
/// Generates Flowcast REST clients based on OpenAPI documents referenced by <see cref="RestSettings"/>.
/// </summary>
public sealed class OpenApiCodeGenerator
{
    private const int BodySortOrder = 4;

    /// <summary>
    /// Generates files for the supplied configuration.
    /// </summary>
    public GenerationResult Generate(RestSettingsDocument document, GenerationOptions options)
    {
        if (document == null)
        {
            throw new ArgumentNullException(nameof(document));
        }

        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }

        options.Validate();

        var operations = new List<OperationDefinition>();
        var warnings = new List<string>();
        var schemaRegistry = new SchemaRegistry(options.ModelNamespace);

        foreach (var relativePath in document.Settings.Documents)
        {
            var resolvedPath = document.ResolvePath(relativePath);
            if (!File.Exists(resolvedPath))
            {
                throw new FileNotFoundException("OpenAPI document '" + relativePath + "' could not be found.", resolvedPath);
            }

            OpenApiDiagnostic diagnostic;
            OpenApiDocument openApiDocument;
            using (var stream = File.OpenRead(resolvedPath))
            {
                var reader = new OpenApiStreamReader();
                openApiDocument = reader.Read(stream, out diagnostic);
            }

            if (diagnostic.Errors.Count > 0)
            {
                foreach (var error in diagnostic.Errors)
                {
                    warnings.Add(Path.GetFileName(resolvedPath) + ": " + error.Message);
                }
            }

            schemaRegistry.Register(openApiDocument);
            ProcessDocument(openApiDocument, operations, schemaRegistry, warnings);
        }

        var files = new List<GeneratedFile>
        {
            CreateResultFile(options.Namespace)
        };

        var restClientFile = CreateRestClientFile(options.Namespace, operations);
        files.Add(restClientFile);

        var modelsFile = schemaRegistry.CreateModelFile();
        if (modelsFile != null)
        {
            files.Add(modelsFile);
        }

        return new GenerationResult(files, warnings);
    }

    private void ProcessDocument(OpenApiDocument document, ICollection<OperationDefinition> operations, SchemaRegistry schemaRegistry, ICollection<string> warnings)
    {
        if (document.Paths == null)
        {
            return;
        }

        foreach (var kvp in document.Paths)
        {
            var path = kvp.Key;
            var pathItem = kvp.Value;
            if (pathItem == null)
            {
                continue;
            }

            foreach (var operationPair in pathItem.Operations)
            {
                var operationType = operationPair.Key;
                var operation = operationPair.Value;
                var methodName = ResolveOperationName(operation, operationType, path);
                var parameters = ResolveParameters(pathItem, operation, schemaRegistry);
                var returnType = ResolveReturnType(operation, schemaRegistry, warnings, methodName);

                operations.Add(new OperationDefinition(
                    methodName,
                    returnType.ReturnType,
                    returnType.IsGeneric,
                    operationType.ToString().ToUpperInvariant(),
                    path,
                    operation.Summary,
                    operation.Description,
                    parameters,
                    returnType.UsesCollections || parameters.Any(p => p.Type.UsesCollections),
                    returnType.UsesJsonElement || parameters.Any(p => p.Type.UsesJsonElement)));
            }
        }
    }

    private static GeneratedFile CreateRestClientFile(string @namespace, IReadOnlyCollection<OperationDefinition> operations)
    {
        var builder = new StringBuilder();
        var usings = new SortedSet<string>(StringComparer.Ordinal) { "System" };
        if (operations.Any(o => o.UsesCollections))
        {
            usings.Add("System.Collections.Generic");
        }

        if (operations.Any(o => o.UsesJsonElement))
        {
            usings.Add("System.Text.Json");
        }

        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        foreach (var import in usings)
        {
            builder.Append("using ");
            builder.Append(import);
            builder.AppendLine(";");
        }

        builder.AppendLine();
        builder.Append("namespace ");
        builder.AppendLine(@namespace);
        builder.AppendLine();
        builder.AppendLine("public static partial class FlowcastRest");
        builder.AppendLine("{");

        foreach (var operation in operations.OrderBy(o => o.MethodName, StringComparer.Ordinal))
        {
            AppendOperation(builder, operation);
            builder.AppendLine();
        }

        builder.AppendLine("}");
        return new GeneratedFile("FlowcastRest.g.cs", builder.ToString());
    }

    private static GeneratedFile CreateResultFile(string @namespace)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine();
        builder.Append("namespace ");
        builder.AppendLine(@namespace);
        builder.AppendLine();
        builder.AppendLine("public class Result");
        builder.AppendLine("{");
        builder.AppendLine("    protected Result(bool isSuccess, string? error)");
        builder.AppendLine("    {");
        builder.AppendLine("        IsSuccess = isSuccess;");
        builder.AppendLine("        Error = error;");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    public bool IsSuccess { get; }");
        builder.AppendLine("    public bool IsFailure => !IsSuccess;");
        builder.AppendLine("    public string? Error { get; }");
        builder.AppendLine();
        builder.AppendLine("    public static Result Success() => new Result(true, null);");
        builder.AppendLine();
        builder.AppendLine("    public static Result Failure(string error)");
        builder.AppendLine("    {");
        builder.AppendLine("        if (string.IsNullOrWhiteSpace(error))");
        builder.AppendLine("        {");
        builder.AppendLine("            throw new ArgumentException(\"A failure result requires an error message.\", nameof(error));");
        }
        builder.AppendLine();
        builder.AppendLine("        return new Result(false, error);");
        builder.AppendLine("    }");
        builder.AppendLine("}");
        builder.AppendLine();
        builder.AppendLine("public sealed class Result<T> : Result");
        builder.AppendLine("{");
        builder.AppendLine("    private Result(bool isSuccess, T? value, string? error)");
        builder.AppendLine("        : base(isSuccess, error)");
        builder.AppendLine("    {");
        builder.AppendLine("        Value = value;");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    public T? Value { get; }");
        builder.AppendLine();
        builder.AppendLine("    public static Result<T> Success(T value) => new Result<T>(true, value, null);");
        builder.AppendLine();
        builder.AppendLine("    public static Result<T> Failure(string error)");
        builder.AppendLine("    {");
        builder.AppendLine("        if (string.IsNullOrWhiteSpace(error))");
        builder.AppendLine("        {");
        builder.AppendLine("            throw new ArgumentException(\"A failure result requires an error message.\", nameof(error));");
        }
        builder.AppendLine();
        builder.AppendLine("        return new Result<T>(false, default, error);");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        return new GeneratedFile("Result.g.cs", builder.ToString());
    }

    private static void AppendOperation(StringBuilder builder, OperationDefinition operation)
    {
        if (!string.IsNullOrWhiteSpace(operation.Summary))
        {
            builder.AppendLine("    /// <summary>");
            builder.Append("    /// ");
            builder.AppendLine(NormalizeComment(operation.Summary));
            builder.AppendLine("    /// </summary>");
        }

        if (!string.IsNullOrWhiteSpace(operation.Description))
        {
            builder.AppendLine("    /// <remarks>");
            foreach (var line in NormalizeComment(operation.Description).Split('\n'))
            {
                builder.Append("    /// ");
                builder.AppendLine(line);
            }
            builder.AppendLine("    /// </remarks>");
        }

        builder.AppendLine("    /// <remarks>HTTP " + operation.HttpMethod + " " + operation.Path + "</remarks>");
        foreach (var parameter in operation.Parameters)
        {
            var description = string.IsNullOrWhiteSpace(parameter.Description)
                ? "Value for '" + parameter.Name + "'."
                : NormalizeComment(parameter.Description);
            builder.AppendLine("    /// <param name=\"" + parameter.Name + "\">" + description + "</param>");
        }

        var parameterList = string.Join(", ", operation.Parameters.Select(p => p.Type.Declaration + " " + p.Name));
        builder.Append("    public static ");
        builder.Append(operation.ReturnType);
        builder.Append(' ');
        builder.Append(operation.MethodName);
        builder.Append('(');
        builder.Append(parameterList);
        builder.AppendLine(")");
        builder.AppendLine("    {");
        builder.AppendLine("        throw new NotImplementedException(\"Generated method stub. Connect your HTTP client implementation here.\");");
        builder.AppendLine("    }");
    }

    private static string ResolveOperationName(OpenApiOperation operation, OperationType operationType, string path)
    {
        if (!string.IsNullOrWhiteSpace(operation.OperationId))
        {
            return NameUtilities.EnsureValidIdentifier(NameUtilities.ToPascalCase(operation.OperationId), true);
        }

        var fallback = operationType.ToString() + " " + path;
        fallback = fallback.Replace("{", "By ");
        fallback = fallback.Replace("}", string.Empty);
        fallback = fallback.Replace('/', ' ');
        return NameUtilities.EnsureValidIdentifier(NameUtilities.ToPascalCase(fallback), true);
    }

    private static IReadOnlyList<MethodParameter> ResolveParameters(OpenApiPathItem pathItem, OpenApiOperation operation, SchemaRegistry schemaRegistry)
    {
        var parameters = new Dictionary<string, MethodParameter>(StringComparer.Ordinal);

        Action<IEnumerable<OpenApiParameter>?> addParameters = source =>
        {
            if (source == null)
            {
                return;
            }

            foreach (var parameter in source)
            {
                var key = parameter.In + ":" + parameter.Name;
                parameters[key] = CreateParameter(parameter, schemaRegistry);
            }
        };

        addParameters(pathItem.Parameters);
        addParameters(operation.Parameters);

        if (operation.RequestBody != null)
        {
            var requestParameter = CreateBodyParameter(operation.RequestBody, schemaRegistry);
            if (requestParameter != null)
            {
                var key = "body:" + requestParameter.Name;
                parameters[key] = requestParameter;
            }
        }

        return parameters.Values
            .OrderBy(p => p.SortOrder)
            .ThenBy(p => p.Name, StringComparer.Ordinal)
            .ToList();
    }

    private static int GetSortOrder(ParameterLocation? location)
    {
        switch (location)
        {
            case ParameterLocation.Path:
                return 0;
            case ParameterLocation.Query:
                return 1;
            case ParameterLocation.Header:
                return 2;
            case ParameterLocation.Cookie:
                return 3;
            default:
                return BodySortOrder;
        }
    }

    private static MethodParameter CreateParameter(OpenApiParameter parameter, SchemaRegistry schemaRegistry)
    {
        var schema = parameter.Schema ?? new OpenApiSchema { Type = "string" };
        var resolved = schemaRegistry.ResolveType(schema, parameter.Required, TypeUsage.Client);
        var name = NameUtilities.EnsureValidIdentifier(NameUtilities.ToCamelCase(parameter.Name));
        return new MethodParameter(name, parameter.Description, resolved, GetSortOrder(parameter.In));
    }

    private static MethodParameter? CreateBodyParameter(OpenApiRequestBody body, SchemaRegistry schemaRegistry)
    {
        if (body.Content == null || body.Content.Count == 0)
        {
            return null;
        }

        var schema = ResolveContentSchema(body.Content);
        if (schema == null)
        {
            return null;
        }

        var resolved = schemaRegistry.ResolveType(schema, body.Required, TypeUsage.Client);
        var candidateName = body.Content.Keys.FirstOrDefault() == "application/json" ? "request" : "body";
        var name = NameUtilities.EnsureValidIdentifier(NameUtilities.ToCamelCase(candidateName));
        return new MethodParameter(name, body.Description, resolved, BodySortOrder);
    }

    private static OpenApiSchema? ResolveContentSchema(IDictionary<string, OpenApiMediaType> content)
    {
        if (content.TryGetValue("application/json", out var json))
        {
            return json.Schema;
        }

        return content.Values.FirstOrDefault()?.Schema;
    }

    private static (string ReturnType, bool IsGeneric, bool UsesCollections, bool UsesJsonElement) ResolveReturnType(OpenApiOperation operation, SchemaRegistry schemaRegistry, ICollection<string> warnings, string methodName)
    {
        var successStatusCodes = new[] { "200", "201", "202", "204" };
        foreach (var status in successStatusCodes)
        {
            if (operation.Responses.TryGetValue(status, out var response))
            {
                if (status == "204")
                {
                    return ("Result", false, false, false);
                }

                var schema = ResolveResponseSchema(response);
                if (schema == null)
                {
                    return ("Result", false, false, false);
                }

                var resolved = schemaRegistry.ResolveType(schema, true, TypeUsage.Client);
                return ("Result<" + resolved.Declaration + ">", true, resolved.UsesCollections, resolved.UsesJsonElement);
            }
        }

        if (operation.Responses.TryGetValue("default", out var defaultResponse))
        {
            var schema = ResolveResponseSchema(defaultResponse);
            if (schema != null)
            {
                var resolved = schemaRegistry.ResolveType(schema, true, TypeUsage.Client);
                return ("Result<" + resolved.Declaration + ">", true, resolved.UsesCollections, resolved.UsesJsonElement);
            }
        }

        warnings.Add(methodName + ": Could not determine a successful response payload. Falling back to Result.");
        return ("Result", false, false, false);
    }

    private static OpenApiSchema? ResolveResponseSchema(OpenApiResponse response)
    {
        if (response.Content == null || response.Content.Count == 0)
        {
            return null;
        }

        if (response.Content.TryGetValue("application/json", out var json))
        {
            return json.Schema;
        }

        return response.Content.Values.FirstOrDefault()?.Schema;
    }

    private static string NormalizeComment(string value)
    {
        var parts = value.Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
        for (var i = 0; i < parts.Length; i++)
        {
            parts[i] = parts[i].Trim();
        }

        return string.Join("\n", parts);
    }

    private sealed class OperationDefinition
    {
        public OperationDefinition(
            string methodName,
            string returnType,
            bool isGeneric,
            string httpMethod,
            string path,
            string? summary,
            string? description,
            IReadOnlyList<MethodParameter> parameters,
            bool usesCollections,
            bool usesJsonElement)
        {
            MethodName = methodName;
            ReturnType = returnType;
            IsGeneric = isGeneric;
            HttpMethod = httpMethod;
            Path = path;
            Summary = summary;
            Description = description;
            Parameters = parameters;
            UsesCollections = usesCollections;
            UsesJsonElement = usesJsonElement;
        }

        public string MethodName { get; }

        public string ReturnType { get; }

        public bool IsGeneric { get; }

        public string HttpMethod { get; }

        public string Path { get; }

        public string? Summary { get; }

        public string? Description { get; }

        public IReadOnlyList<MethodParameter> Parameters { get; }

        public bool UsesCollections { get; }

        public bool UsesJsonElement { get; }
    }

    private sealed class MethodParameter
    {
        public MethodParameter(string name, string? description, SchemaRegistry.ResolvedType type, int sortOrder)
        {
            Name = name;
            Description = description;
            Type = type;
            SortOrder = sortOrder;
        }

        public string Name { get; }

        public string? Description { get; }

        public SchemaRegistry.ResolvedType Type { get; }

        public int SortOrder { get; }
    }
}
