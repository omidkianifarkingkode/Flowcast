using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.OpenApi.Models;

namespace Flowcast.CodeGenerator;

internal sealed class SchemaRegistry
{
    private readonly Dictionary<string, SchemaInfo> _schemas = new Dictionary<string, SchemaInfo>(StringComparer.Ordinal);

    public SchemaRegistry(string modelNamespace)
    {
        ModelNamespace = modelNamespace;
    }

    public string ModelNamespace { get; }

    public void Register(OpenApiDocument document)
    {
        if (document.Components?.Schemas == null)
        {
            return;
        }

        foreach (var kvp in document.Components.Schemas)
        {
            if (string.IsNullOrWhiteSpace(kvp.Key))
            {
                continue;
            }

            _schemas[kvp.Key] = new SchemaInfo(kvp.Key, NameUtilities.ToPascalCase(kvp.Key), kvp.Value);
        }
    }

    public ResolvedType ResolveType(OpenApiSchema schema, bool required, TypeUsage usage)
    {
        if (schema == null)
        {
            throw new ArgumentNullException(nameof(schema));
        }

        if (schema.Reference != null && !string.IsNullOrEmpty(schema.Reference.Id))
        {
            var referenceId = schema.Reference.Id;
            if (_schemas.TryGetValue(referenceId, out var info))
            {
                if (info.IsInlinePrimitive)
                {
                    var primitive = ResolvePrimitiveType(info.Schema, required, usage);
                    return primitive.WithNullable(!required || schema.Nullable || info.Schema.Nullable);
                }

                var baseType = usage == TypeUsage.Client
                    ? ModelNamespace + "." + info.Name
                    : info.Name;
                var isNullable = !required || schema.Nullable || info.Schema.Nullable;
                return new ResolvedType(baseType, false, false, false, isNullable);
            }

            var fallback = NameUtilities.ToPascalCase(referenceId);
            var qualified = usage == TypeUsage.Client ? ModelNamespace + "." + fallback : fallback;
            return new ResolvedType(qualified, false, false, false, !required || schema.Nullable);
        }

        return ResolvePrimitiveType(schema, required, usage);
    }

    public GeneratedFile? CreateModelFile()
    {
        var models = CollectModels().ToList();
        if (models.Count == 0)
        {
            return null;
        }

        var builder = new StringBuilder();
        var usings = new SortedSet<string>(StringComparer.Ordinal)
        {
            "System"
        };
        var needsCollections = false;
        var needsJsonElement = false;

        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");

        foreach (var model in models)
        {
            foreach (var property in model.Properties)
            {
                if (property.Type.UsesCollections)
                {
                    needsCollections = true;
                }

                if (property.Type.UsesJsonElement)
                {
                    needsJsonElement = true;
                }
            }
        }

        usings.Add("System.Text.Json.Serialization");
        if (needsCollections)
        {
            usings.Add("System.Collections.Generic");
        }

        if (needsJsonElement)
        {
            usings.Add("System.Text.Json");
        }

        foreach (var import in usings)
        {
            builder.Append("using ");
            builder.Append(import);
            builder.AppendLine(";");
        }

        builder.AppendLine();
        builder.Append("namespace ");
        builder.AppendLine(ModelNamespace);
        builder.AppendLine();

        foreach (var model in models)
        {
            AppendModel(builder, model);
            builder.AppendLine();
        }

        return new GeneratedFile("Models.g.cs", builder.ToString());
    }

    private IEnumerable<ModelDefinition> CollectModels()
    {
        var emitted = new HashSet<string>(StringComparer.Ordinal);
        foreach (var schema in _schemas.Values)
        {
            if (!schema.IsInlinePrimitive && emitted.Add(schema.Name))
            {
                yield return CreateModel(schema);
            }
        }
    }

    private ModelDefinition CreateModel(SchemaInfo info)
    {
        var properties = new List<ModelProperty>();
        var required = info.Schema.Required ?? new HashSet<string>();
        if (info.Schema.Properties != null)
        {
            foreach (var property in info.Schema.Properties)
            {
                var propertyName = NameUtilities.EnsureValidIdentifier(NameUtilities.ToPascalCase(property.Key), true);
                var resolved = ResolveType(property.Value, required.Contains(property.Key), TypeUsage.Model);
                properties.Add(new ModelProperty(propertyName, property.Key, property.Value.Description, resolved));
            }
        }

        return new ModelDefinition(info.Name, info.Schema.Description, properties);
    }

    private ResolvedType ResolvePrimitiveType(OpenApiSchema schema, bool required, TypeUsage usage)
    {
        var allowNull = !required || schema.Nullable;
        switch (schema.Type)
        {
            case "string":
                return new ResolvedType("string", false, false, false, allowNull);
            case "integer":
                var integerType = schema.Format switch
                {
                    "int64" => "long",
                    "int32" => "int",
                    "int16" => "short",
                    "byte" => "byte",
                    _ => "int"
                };
                return new ResolvedType(integerType, true, false, false, allowNull);
            case "number":
                var numberType = schema.Format switch
                {
                    "float" => "float",
                    "double" => "double",
                    "decimal" => "decimal",
                    _ => "double"
                };
                return new ResolvedType(numberType, true, false, false, allowNull);
            case "boolean":
                return new ResolvedType("bool", true, false, false, allowNull);
            case "array":
                var itemSchema = schema.Items ?? new OpenApiSchema { Type = "object" };
                var itemType = ResolveType(itemSchema, true, usage);
                return new ResolvedType("System.Collections.Generic.IReadOnlyList<" + itemType.Declaration + ">", false, true, itemType.UsesJsonElement, allowNull);
            case "object":
            default:
                return new ResolvedType("System.Text.Json.JsonElement", false, false, true, allowNull);
        }
    }

    private void AppendModel(StringBuilder builder, ModelDefinition model)
    {
        if (!string.IsNullOrWhiteSpace(model.Description))
        {
            builder.AppendLine("/// <summary>");
            builder.Append("/// ");
            builder.AppendLine(model.Description.Replace("\n", " "));
            builder.AppendLine("/// </summary>");
        }

        builder.Append("public sealed class ");
        builder.AppendLine(model.Name);
        builder.AppendLine("{");

        foreach (var property in model.Properties)
        {
            if (!string.IsNullOrWhiteSpace(property.Description))
            {
                builder.AppendLine("    /// <summary>");
                builder.Append("    /// ");
                builder.AppendLine(property.Description.Replace("\n", " "));
                builder.AppendLine("    /// </summary>");
            }

            builder.Append("    [JsonPropertyName(\"");
            builder.Append(property.SerializedName);
            builder.AppendLine("\")]");
            builder.Append("    public ");
            builder.Append(property.Type.Declaration);
            builder.Append(' ');
            builder.Append(property.Name);

            if (!property.Type.IsValueType && !property.Type.IsNullable)
            {
                builder.Append(" { get; set; } = default!;");
            }
            else
            {
                builder.Append(" { get; set; }");
            }

            builder.AppendLine();
            builder.AppendLine();
        }

        builder.AppendLine("}");
    }

    internal readonly struct ResolvedType
    {
        public ResolvedType(string baseType, bool isValueType, bool usesCollections, bool usesJsonElement, bool isNullable)
        {
            BaseType = baseType;
            IsValueType = isValueType;
            UsesCollections = usesCollections;
            UsesJsonElement = usesJsonElement;
            IsNullable = isNullable;
        }

        public string BaseType { get; }

        public bool IsValueType { get; }

        public bool UsesCollections { get; }

        public bool UsesJsonElement { get; }

        public bool IsNullable { get; }

        public string Declaration => IsNullable ? BaseType + "?" : BaseType;

        public ResolvedType WithNullable(bool isNullable)
        {
            return new ResolvedType(BaseType, IsValueType, UsesCollections, UsesJsonElement, isNullable);
        }
    }

    private sealed class SchemaInfo
    {
        public SchemaInfo(string key, string name, OpenApiSchema schema)
        {
            Key = key;
            Name = name;
            Schema = schema;
        }

        public string Key { get; }

        public string Name { get; }

        public OpenApiSchema Schema { get; }

        public bool IsInlinePrimitive =>
            (Schema.Properties == null || Schema.Properties.Count == 0) &&
            (Schema.Enum == null || Schema.Enum.Count == 0) &&
            (Schema.AllOf == null || Schema.AllOf.Count == 0) &&
            (Schema.AnyOf == null || Schema.AnyOf.Count == 0) &&
            (Schema.OneOf == null || Schema.OneOf.Count == 0) &&
            (Schema.Type == "string" || Schema.Type == "integer" || Schema.Type == "number" || Schema.Type == "boolean");
    }

    private sealed class ModelDefinition
    {
        public ModelDefinition(string name, string? description, IReadOnlyList<ModelProperty> properties)
        {
            Name = name;
            Description = description;
            Properties = properties;
        }

        public string Name { get; }

        public string? Description { get; }

        public IReadOnlyList<ModelProperty> Properties { get; }
    }

    private sealed class ModelProperty
    {
        public ModelProperty(string name, string serializedName, string? description, ResolvedType type)
        {
            Name = name;
            SerializedName = serializedName;
            Description = description;
            Type = type;
        }

        public string Name { get; }

        public string SerializedName { get; }

        public string? Description { get; }

        public ResolvedType Type { get; }
    }
}

internal enum TypeUsage
{
    Model,
    Client
}
