using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.OpenApi.Models;

namespace Flowcast.CodeGenerator;

internal sealed class SchemaRegistry
{
    private readonly Dictionary<string, SchemaInfo> _schemas = new(StringComparer.Ordinal);

    public SchemaRegistry(string modelNamespace)
    {
        ModelNamespace = modelNamespace;
    }

    public string ModelNamespace { get; }

    public void Register(OpenApiDocument document)
    {
        if (document.Components?.Schemas == null)
        {
            return;
        }

        foreach (var kvp in document.Components.Schemas)
        {
            if (string.IsNullOrWhiteSpace(kvp.Key))
            {
                continue;
            }

            _schemas[kvp.Key] = new SchemaInfo(kvp.Key, NameUtilities.ToPascalCase(kvp.Key), kvp.Value);
        }
    }

    public ResolvedType ResolveType(OpenApiSchema schema, bool required, TypeUsage usage)
    {
        if (schema == null)
        {
            throw new ArgumentNullException(nameof(schema));
        }

        if (schema.Reference != null && !string.IsNullOrEmpty(schema.Reference.Id))
        {
            var referenceId = schema.Reference.Id;
            if (_schemas.TryGetValue(referenceId, out var info))
            {
                if (info.IsInlinePrimitive)
                {
                    var primitive = ResolvePrimitiveType(info.Schema, required, usage);
                    return primitive.WithNullable(!required || schema.Nullable || info.Schema.Nullable);
                }

                var baseType = usage == TypeUsage.Client
                    ? $"{ModelNamespace}.{info.Name}"
                    : info.Name;
                var isNullable = !required || schema.Nullable || info.Schema.Nullable;
                return new ResolvedType(baseType, isValueType: false, usesCollections: false, usesJsonElement: false, isNullable: isNullable);
            }

            var fallback = NameUtilities.ToPascalCase(referenceId);
            var qualified = usage == TypeUsage.Client ? $"{ModelNamespace}.{fallback}" : fallback;
            return new ResolvedType(qualified, isValueType: false, usesCollections: false, usesJsonElement: false, isNullable: !required || schema.Nullable);
        }

        return ResolvePrimitiveType(schema, required, usage);
    }

    public GeneratedFile? CreateModelFile()
    {
        var models = CollectModels().ToList();
        if (models.Count == 0)
        {
            return null;
        }

        var builder = new StringBuilder();
        var usings = new SortedSet<string>(StringComparer.Ordinal)
        {
            "System"
        };
        var needsCollections = false;
        var needsJsonElement = false;

        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");

        foreach (var model in models)
        {
            foreach (var property in model.Properties)
            {
                if (property.Type.UsesCollections)
                {
                    needsCollections = true;
                }

                if (property.Type.UsesJsonElement)
                {
                    needsJsonElement = true;
                }
            }
        }

        usings.Add("System.Text.Json.Serialization");
        if (needsCollections)
        {
            usings.Add("System.Collections.Generic");
        }

        if (needsJsonElement)
        {
            usings.Add("System.Text.Json");
        }

        foreach (var import in usings)
        {
            builder.Append("using ");
            builder.Append(import);
            builder.AppendLine(";");
        }

        builder.AppendLine();
        builder.Append("namespace ");
        builder.AppendLine(ModelNamespace);
        builder.AppendLine();

        foreach (var model in models)
        {
            AppendModel(builder, model);
            builder.AppendLine();
        }

        return new GeneratedFile("Models.g.cs", builder.ToString());
    }

    private IEnumerable<ModelDefinition> CollectModels()
    {
        var emitted = new HashSet<string>(StringComparer.Ordinal);
        foreach (var schema in _schemas.Values)
        {
            if (!schema.IsInlinePrimitive && emitted.Add(schema.Name))
            {
                yield return CreateModel(schema);
            }
        }
    }

    private ModelDefinition CreateModel(SchemaInfo info)
    {
        var properties = new List<ModelProperty>();
        var required = info.Schema.Required ?? new HashSet<string>();
        if (info.Schema.Properties != null)
        {
            foreach (var property in info.Schema.Properties)
            {
                var propertyName = NameUtilities.EnsureValidIdentifier(NameUtilities.ToPascalCase(property.Key), true);
                var resolved = ResolveType(property.Value, required.Contains(property.Key), TypeUsage.Model);
                properties.Add(new ModelProperty(propertyName, property.Key, property.Value.Description, resolved));
            }
        }

        return new ModelDefinition(info.Name, info.Schema.Description, properties);
    }

    private ResolvedType ResolvePrimitiveType(OpenApiSchema schema, bool required, TypeUsage usage)
    {
        var allowNull = !required || schema.Nullable;
        switch (schema.Type)
        {
            case "string":
                return new ResolvedType("string", isValueType: false, usesCollections: false, usesJsonElement: false, isNullable: allowNull);
            case "integer":
                var integerType = schema.Format switch
                {
                    "int64" => "long",
                    "int32" => "int",
                    "int16" => "short",
                    "byte" => "byte",
                    _ => "int"
                };
                return new ResolvedType(integerType, isValueType: true, usesCollections: false, usesJsonElement: false, isNullable: allowNull);
            case "number":
                var numberType = schema.Format switch
                {
                    "float" => "float",
                    "double" => "double",
                    "decimal" => "decimal",
                    _ => "double"
                };
                return new ResolvedType(numberType, isValueType: true, usesCollections: false, usesJsonElement: false, isNullable: allowNull);
            case "boolean":
                return new ResolvedType("bool", isValueType: true, usesCollections: false, usesJsonElement: false, isNullable: allowNull);
            case "array":
                var itemSchema = schema.Items ?? new OpenApiSchema { Type = "object" };
                var itemType = ResolveType(itemSchema, required: true, usage);
                return new ResolvedType($"System.Collections.Generic.IReadOnlyList<{itemType.Declaration}>", isValueType: false, usesCollections: true, usesJsonElement: itemType.UsesJsonElement, isNullable: allowNull);
            case "object":
            default:
                return new ResolvedType("System.Text.Json.JsonElement", isValueType: false, usesCollections: false, usesJsonElement: true, isNullable: allowNull);
        }
    }

    private void AppendModel(StringBuilder builder, ModelDefinition model)
    {
        if (!string.IsNullOrWhiteSpace(model.Description))
        {
            builder.AppendLine("/// <summary>");
            builder.Append("/// ");
            builder.AppendLine(model.Description.Replace("\n", " ")); // single line summary
            builder.AppendLine("/// </summary>");
        }

        builder.Append("public sealed class ");
        builder.AppendLine(model.Name);
        builder.AppendLine("{");

        foreach (var property in model.Properties)
        {
            if (!string.IsNullOrWhiteSpace(property.Description))
            {
                builder.AppendLine("    /// <summary>");
                builder.Append("    /// ");
                builder.AppendLine(property.Description.Replace("\n", " "));
                builder.AppendLine("    /// </summary>");
            }

            builder.Append("    [JsonPropertyName(\"");
            builder.Append(property.SerializedName);
            builder.AppendLine("\")]");
            builder.Append("    public ");
            builder.Append(property.Type.Declaration);
            builder.Append(' ');
            builder.Append(property.Name);

            if (!property.Type.IsValueType && !property.Type.IsNullable)
            {
                builder.Append(" { get; set; } = default!;");
            }
            else
            {
                builder.Append(" { get; set; }");
            }

            builder.AppendLine();
            builder.AppendLine();
        }

        builder.AppendLine("}");
    }

    internal readonly record struct ResolvedType(string BaseType, bool IsValueType, bool UsesCollections, bool UsesJsonElement, bool IsNullable)
    {
        public string Declaration => IsNullable ? $"{BaseType}?" : BaseType;

        public ResolvedType WithNullable(bool isNullable) => new(BaseType, IsValueType, UsesCollections, UsesJsonElement, isNullable);
    }

    private sealed record SchemaInfo(string Key, string Name, OpenApiSchema Schema)
    {
        public bool IsInlinePrimitive =>
            (Schema.Properties == null || Schema.Properties.Count == 0) &&
            (Schema.Enum == null || Schema.Enum.Count == 0) &&
            (Schema.AllOf == null || Schema.AllOf.Count == 0) &&
            (Schema.AnyOf == null || Schema.AnyOf.Count == 0) &&
            (Schema.OneOf == null || Schema.OneOf.Count == 0) &&
            Schema.Type is "string" or "integer" or "number" or "boolean";
    }

    private sealed record ModelDefinition(string Name, string? Description, IReadOnlyList<ModelProperty> Properties);

    private sealed record ModelProperty(string Name, string SerializedName, string? Description, ResolvedType Type);
}

internal enum TypeUsage
{
    Model,
    Client
}
